		   Spring Boot REST API Development
.....................................................................................

In General , we can build many types of apps in Spring boot

Common types of apps

1.CommandLine application.
2.Web Applications

Web Applications:

1.Dynamic Web Application:
   Type of web application which talks to datasources, read data , build html pages.
 Users finally access html pages...
 Building web sites.

How to build Dynamic web application in Spring /Spring Boot?

 Spring provides a module/project called "Spring-MVC"


What is Spring?

 Spring java and JEE framework
 Framework is collections of many things called projects and modules.

 Spring Provides many modules, each module offers features for different type of application.

Spring Projects:
................

1.Spring core - Spring Framework
   At core, this project is very core, all projects which was built on the top of Spring core..

2.Spring Boot  - Advanced Spring configuration System

3.Spring Web Frameworks
   ->Spring MVC 
       Spring WebFlux

 Spring MVC | Spring Web Flux
   => Dynamic web apps - Web application with User interface
   => Web services


Web Service:

1.SOAP Web Service -Spring Web Services-4.0.10
2.RestFull Web Services  - Spring MVC
3.GraphQL -  Alternate to REST
....................................................................................
....................................................................................
		Spring boot and REST full web service Development
....................................................................................


What is REST?

RE-Reprentational
S-State 
T-Transfer

RE-Reprentational
  Data format - JSON,XML,AVRO,PROTOBuf,pdf,media
S - State 
   Data - Objects and Collections

T- Transfer
  Data is converted into any format which is user interested and transfer over http protocal.

REST is  just specification which was released as part of http specification by co author of http protocal , Roy Fielding.

https://ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm

....................................................................................
			   REST Working Principles
....................................................................................

REST Works based on HTTP protocal and its semantic verbs

POST -----> CREATE
GET ------ >READ
PUT | PATCH--------->UPDATE
DELETE-------DELETE

CURD Operations
.....................................................................................

Steps to build REST API

1.Resource
  Domain model, eg Order,Customer,Student,Trainer,Subject

2.Expose api
   Every resource has api , which helps to transfer and get data from and to...

3.Connect to DataSource
   Every api connects to data source in order to get data/read data..

How to represent Resource?

public class OrderController{

}

How to Expose api?


public class OrderController{

 //apis
  public List<Orders> findAll(){}
  public Order findById(Long id){}
  public Orders create(Order order){}
}

how resource and apis are mapped with "HTTP" protocal?

1.Every resource must be identified by unique "URL" "/api/orders"

2.Every api is identified by "http verbs" - GET,POST,PUT,DELETE

How to map url and map http verbs in spring?

 Spring MVC offers annotations
.....................................................................................

Spring boot with Restfull web development:
..........................................

in order to run web apps, we need web container.
Spring boot brings embeded web container - tomcat by default.

Spring boot web apps are packaged as "fat jar/uber jar" file.

Spring web app/REST APP Types:
..............................

1.Blocking web app
   default web app
 Spring Module is "spring-web" / "spring-mvc"
2.Non Blocking web app
 Spring module is "spring-webflux"
  
.....................................................................................
			 Spring boot Rest api development

1.create project with following dependency(core)
 project can be created 
  ->standalone maven project and add dependency.
  ->spring inializer
    https://start.spring.io/


Project Name: restapp
pom.xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>3.3.1</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>
	<groupId>com.ibm</groupId>
	<artifactId>restapp</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>restapp</name>
	<description>Rest api development</description>
	<url/>
	<licenses>
		<license/>
	</licenses>
	<developers>
		<developer/>
	</developers>
	<scm>
		<connection/>
		<developerConnection/>
		<tag/>
		<url/>
	</scm>
	<properties>
		<java.version>17</java.version>
	</properties>
	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
	</dependencies>

	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
		</plugins>
	</build>

</project>

package com.ibm.web;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class RestApplication {

	public static void main(String[] args) {
		SpringApplication.run(RestApplication.class, args);
	}

}

After Running we can test application:
http://localhost:8080/

We get White lable Error.

 if you see this message then your app is running succfully.
.....................................................................................
	 API Development Steps


1.Define Resource
 In Spring Resource is called "Controller" so the name of the Resource would be like below
  CustomerController,OrderController

package com.ibm.web.api.hello;

public class HelloController {
}


2.Define api inside Resource

   findAll, findById,save,update,remove

package com.ibm.web.api.hello;


public class HelloController {

    public String sayHello() {
        return "Hello";
    }
}


3.Use Annotations to mark Resource apis..

In order to convert normal class and methods into Rest aware

Annotations:
1.@RestController - @Controller
2.@RequestMapping -  URL mapper
3.Method annotations
  @GetMapping
  @PostMapping
  @PutMapping
  @DeleteMapping

.....
package com.ibm.restapp.api;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

//Resource
@RestController
@RequestMapping("api/greet")
public class GreeterController {

    //API
    @GetMapping
    public String sayHello() {
        return "Hello";
    }
}
..................................................................................
			 CURD Operations
...................................................................................
package com.ibm.restapp.api;

import com.ibm.restapp.api.service.OrderService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("orders")
public class OrderController {
    @Autowired
    private OrderService orderService;

    @GetMapping
    public String findAll() {
        return orderService.findAll();
    }

    @GetMapping
    @RequestMapping("id")
    public String findById() {
        return orderService.findById();
    }

    @PostMapping
    public String create() {
        return orderService.create();
    }

    @PutMapping
    public String update() {
        return orderService.update();
    }

    @DeleteMapping
    public String remove() {
        return orderService.remove();
    }
}
.....................................................................................
			  Hot Reloading/Live Reloading feature
.....................................................................................

Without restarting the server manually every time, when ever code changes, the feature we can add called "hot reloading" through which we can restart the server automatically.

How to enable live reloading?

pom.xml
<dependency>
 <groupId>org.springframework.boot</groupId>
 <artifactId>spring-boot-devtools</artifactId>
 <optional>true</optional>
</dependency>

application.properties
spring.devtools.restart.poll-interval=1s
  This properties tell spring to restart the server after every 1s if there is code change.
....................................................................................
			....................................................................................
			 How to read external properties 
....................................................................................

application.properties
spring.application.name=restapp
hello.message=Hello,How are you?


application.properties
spring.application.name=restapp
hello.message=Hello,How are you?


package com.ibm.web.api.hello.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.env.Environment;
import org.springframework.stereotype.Service;

@Service
public class HelloService {

    @Autowired
    private Environment environment;

    public String sayHello() {
        return environment.getProperty("hello.message", "How are you");
    }
}
package com.ibm.web.api.hello;


import com.ibm.web.api.hello.service.HelloService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("hello")
public class HelloController {

    @Autowired
    private HelloService helloService;

    @GetMapping
    public String sayHello() {
        return helloService.sayHello();
    }
}
.....................................................................................				   How to read data from the user
.....................................................................................

How to pass input to the api?

There are two ways to pass data to the rest api?

1.As part of URL - Parameters
2.As part of Body -Payload



Parameters:

1.Path Parameter
2.Query Parameter
3.Matrix Parameter - optional


1.Path Parameter:
   creating dynamic urls

http://localhost:8080/products/1
http://localhost:8080/products/2
http://localhost:8080/products/3
http://localhost:8080/products/4

HTTP Request structure:

Request contains two segements.

1.Request Headers
  Http Request header, meta information about on going request
2.Request body
  Data what we pass.

Parameters vs Payload
  Parameters and payload both are used to pass data to the server
parameters are sent via url but payload is via body 
.....................................................................................
			Path Parameters-Dynamic URL
.....................................................................................

Syntax:
 /products/{placeholder}
eg:
 /products/1

eg:
package com.ibm.restapp.parameters.path;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("products")
public class ProductsController {

    @GetMapping
    public String findAll() {
        return "products";
    }

    @GetMapping
    @RequestMapping("{id}")
    public String findById(@PathVariable("id") Long id) {
        return "Product  " + id;
    }
}

Testing:
http://localhost:8080/products/10
http://localhost:8080/products/1
http://localhost:8080/products/13
....................................................................................
			Query Parameter/Query String
....................................................................................

Passing more than one parameters

Syntax:

products/filter?category=food&pricegreterthan=100&pricelessthan=5

category is variable
food is value
& is delimeter to separte out other variables.

Here we have three variables
category
pricegreterthan
pricesslessthan


package com.ibm.restapp.parameters.path;

import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("products")
public class ProductsController {

      @GetMapping
    @RequestMapping("filter")
    public String filter(@RequestParam("category") String category, @RequestParam("pricegreaterthan") Long pricegreterthan, @RequestParam("pricelessthan") Long pricelessthan) {
        return category + pricegreterthan + pricelessthan;
    }
}


Testing:
http://localhost:8080/products/filter?category=food&pricegreaterthan=5&pricelessthan=100
....................................................................................
		How to send payload to the server
....................................................................................

RE -Representational State Transfer.
 Sending data in the various format.

Rest supports various data formats
  -XML,JSON,Avro,protobuf,html,pdf,doc....

Now  a days, JSON is most popular data format.

How to send json from the client and how spring converts into java object?

JSON:
 java script object noation, is data fromat invented in 2000 for sending and reciving data from web and to web.
JSON is plain text or ascii file , very light weight format.

JSON Parser is program which converts string to object and object to string.

JSON (string) To java -  string to object
Java object to JSON(string) - object to string.

Spring boot has in built json parser called "Jackson" parser.

Use case: 
 I am going to send product details as json, and inside spring boot we convert into product object.


package com.ibm.restapp.parameters.path;

import com.ibm.restapp.entity.Product;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("products")
public class ProductsController {

  

    @PostMapping
    public String create(@RequestBody Product product) {
        System.out.println(product);
        return "saved";
    }

    
}

Testing:

POST /products

{
    "id": 21,
    "name": "caret",
    "qty": 100,
    "category": "veg"
}
.....................................................................................
			 Return Types
.....................................................................................

What we can return from api?

There are many return types
1.String
2.Object- Collections or Object
3.ResponseEntity
4.void
5.Reactive Types - Mono/Flux - WebFlux

Based on Return type , content/type would be converted

1.String - plain/text
2.Object/Collection - application/json
3.ResponseEntity -  plain/text or application/json
4.void - only status code
5.Reactive - application/json or any type

Response:
 The reponse can have two things.
1.payload - Data which is returned
2.Meta data-headers
  Headers are just variables which hold some values which describe the nature of response.

Response Headers:

1.Content-Type

Content-Type: text/html; charset=utf-8

The MIME type of this content. What type of data server is sending to client.

Basic content type of web is:

  HTML
  Plain/text

Rest content type is :
  
  Representational State Transfer
      |             |
   Data Format     Data
      |
json
xml
pdf
word
etc...
By Default in REST is "json"

2.Content-Length

Content-Length: 348

The length of the response body expressed in 8-bit bytes

3.Date
Date: Tue, 15 Nov 1994 08:12:31 GMT

The date and time that the message was sent (in “HTTP-date” format as defined by RFC 7231)

4.keep-alive
  It is header which talks how long the http connection can exits between server and client default is 60ms

5.Connection
Connection: close

Control options for the current connection and list of hop-by-hop response fields. Deprecated in HTTP/2


.....................................................................................
			Sending Status Code
....................................................................................

HTTP operation Status:

-> informational response - 100 to 199-1X
-> success response -  200-299-2X
-> Redirects  - 300-399 -3X
-> client errors - 400-499 -4X
-> server errrors - 500-599 - 5X

Status Code : 100 to 500
1XX Information Responses

100 Continue
101 Switching Protocols
102 Processing
103 Early Hints

2XX Success

200 OK
201 Created
202 Accepted
203 Non-Authoritative Information
204 No Content
205 Reset Content
206 Partial Content
207 Multi-Status
208 Already Reported
226 IM Used

3XX Redirection
300 Multiple Choices
301 Moved Permanently
302 Found
303 See Other
304 Not Modified
305 Use Proxy
306 Switch Proxy
307 Temporary Redirect
308 Permanent Redirect

4XX Client errors

400 Bad Request
401 Unauthorized
402 Payment Required
403 Forbidden
404 Not Found
405 Method Not Allowed
406 Not Acceptable
407 Proxy Authentication Required
408 Request Timeout
409 Conflict
410 Gone
411 Length Required
412 Precondition Failed
413 Payload Too Large
414 URI Too Long
415 Unsupported Media Type
416 Range Not Satisfiable
417 Expectation Failed
418 I'm a teapot
420 Method Failure
421 Misdirected Request
422 Unprocessable Entity
423 Locked
424 Failed Dependency
426 Upgrade Required
428 Precondition Required
429 Too Many Requests
431 Request Header Fields Too Large
451 Unavailable For Legal Reasons

5XX Server errors
500 Internal Server error
501 Not Implemented
502 Bad Gateway
503 Service Unavailable
504 gateway Timeout
505 Http version not supported
506 Varient Also negotiate
507 Insufficient Storage
508 Loop Detected
510 Not Extended
511 Network Authentication Required
.....................................................................................
 "By default spring sends 200 status for all success request and response."

What if i want to send some special status code?

According to Rest , Post method must return 201.

How to add StatusCode in the Response?


    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public String create(@RequestBody Product product) {
        System.out.println(product);
        return "saved";
    }

....................................................................................
				String
....................................................................................

    @GetMapping
    public String findAll() {
        return "products";
    }

 content-type:
  text/plain
.....................................................................................
				Objects and Collections
....................................................................................
package com.ibm.restapp.response;

import com.ibm.restapp.entity.Customer;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
@RequestMapping("customers")
public class Customers {

    @GetMapping
    public List<Customer> findAll() {
        List<Customer> customers = List.of(
                new Customer(1, "Subramanian", "Coimbatore"),
                new Customer(2, "Murugan", "Coimbatore"),
                new Customer(3, "Karthik", "Chennai")

        );
        return customers;
    }
}
.....................................................................................
			CommandLineRunner Interface for initlaizing data
.....................................................................................

package com.ibm.restapp.response;

import com.ibm.restapp.entity.Customer;
import org.springframework.boot.CommandLineRunner;
import org.springframework.context.annotation.Bean;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
@RequestMapping("customers")
public class Customers {

    List<Customer> customers;

    @Bean
    public CommandLineRunner commandLineRunner() {
        return (arg) -> {
            customers = List.of(
                    new Customer(1, "Subramanian", "Coimbatore"),
                    new Customer(2, "Murugan", "Coimbatore"),
                    new Customer(3, "Karthik", "Chennai"),
                    new Customer(4, "Ram", "Delhi")
            );
        };
    }

    @GetMapping
    public List<Customer> findAll() {
        return customers;
    }
}
...................................................................................
                      How to return single Customer(Object)

package com.ibm.restapp.response;

import com.ibm.restapp.entity.Customer;
import org.springframework.boot.CommandLineRunner;
import org.springframework.context.annotation.Bean;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
@RequestMapping("customers")
public class Customers {

    List<Customer> customers;

    @Bean
    public CommandLineRunner commandLineRunner() {
        return (arg) -> {
            customers = List.of(
                    new Customer(1, "Subramanian", "Coimbatore"),
                    new Customer(2, "Murugan", "Coimbatore"),
                    new Customer(3, "Karthik", "Chennai"),
                    new Customer(4, "Ram", "Delhi")
            );
        };
    }



    @GetMapping
    public List<Customer> findAll() {
        return customers;
    }

    @GetMapping
    @RequestMapping("single")
    public Customer findBySingleCustomer() {
        return  new Customer(1,"Subramanian","Coimbatore");
    }
}
..................................................................................
		     ResponseEntity
...................................................................................

What if i want to send data with custom headers? and custom status code.

ReponseEnity is Object, used to encapuslate meta data.

package com.ibm.restapp.response;

import com.ibm.restapp.entity.Customer;
import org.springframework.boot.CommandLineRunner;
import org.springframework.context.annotation.Bean;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("customers")
public class Customers {

    List<Customer> customers;

    @Bean
    public CommandLineRunner commandLineRunner() {
        return (arg) -> {
            customers = List.of(
                    new Customer(1, "Subramanian", "Coimbatore"),
                    new Customer(2, "Murugan", "Coimbatore"),
                    new Customer(3, "Karthik", "Chennai"),
                    new Customer(4, "Ram", "Delhi")
            );
        };
    }


//    @PostMapping
////    @ResponseStatus(HttpStatus.CREATED)
//    public Customer create(@RequestBody Customer customer) {
//        return customer;
//    }

    @PostMapping
    public ResponseEntity<Customer> create(@RequestBody Customer customer) {
        return ResponseEntity.status(201)
                .header("name", "IBM")
                .header("location", "Bangalore")
                .contentType(MediaType.APPLICATION_JSON)
                .body(customer);
    }

    @GetMapping
    public List<Customer> findAll() {
        return customers;
    }

    @GetMapping
    @RequestMapping("single")
    public Customer findBySingleCustomer() {
        return new Customer(1, "Subramanian", "Coimbatore");
    }
}
.....................................................................................
			void -Return
...................................................................................

void return type does not say to return data, rather return status code.

package com.ibm.restapp.response;

import com.ibm.restapp.entity.Customer;
import org.springframework.boot.CommandLineRunner;
import org.springframework.context.annotation.Bean;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("customers")
public class Customers {

    @DeleteMapping
    @RequestMapping("{id}")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public void delete(@PathVariable("id") Long id) {
        System.out.println("deleting by id : " + id);
    }

}
....................................................................................
			Reactive Programing Spring
			   Project Reactor
				WebFlux
.....................................................................................

What is Reactive Programming?

  Reactive programming is kind of declarative programming,by coimbing many design patterns (Observerable,Iterable,functional programming concepts-pure function)

Why reactive programming? or What is purpose of reactive programming?

 Reactive programming helps to transfer data within application or across application
 in async way.
The reactive-stack web framework, Spring WebFlux, has been added to Spring 5. It is fully non-blocking, supports reactive streams back pressure, and runs on such servers as Netty, Undertow, and Servlet 3.1+ containers.

Reactive Stack:

 Reactive is new programming model, helps to build non blocking / async applications.
 

Traditional web vs Reactive/NonBlocking  web application:
.........................................................

How we use threads,thats where the difference.

In traditional web applications, every request is mapped against a separate dedicated thread - this is called as "Request Per thread Model"

for eg in 1ms , the webserver recieves 100 requests, the web server will have 100 threads.

Request Per thread model drawbacks:

1.Operating system need to maintain so much threads, so that os need more memory, and also operating system need to do context switch a lot, so cpu power is used heavily..

How to manange this?

 We need less threads, thats where new technology was created called "non blocking and async"

Non blocking arch brought  new threading model, where as having limited no of threads, we can achive maximum concurrency...

Threads are reused by multiple request--response handling.
....................................................................................
			Spring and Nonblocking arch
.....................................................................................

Webflux is framework built on the top of "Project reactor", which is spring wrapper..

WebFlux provides a feature to build async and non blocking apps.

Webflux web server is not tomcat, rather we use "netty" server which is non blocking server..

How to create non blocking/ webflux apps?

Note:
 you cant mix blocking and nonblocking dependencies in a single project...




